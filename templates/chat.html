<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Document Chat</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/marked@4.0.0/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');

        body {
            font-family: 'Inter', sans-serif;
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }

        /* Chat tabs scrollbar */
        #chat-tabs {
            scrollbar-width: thin;
            scrollbar-color: #cbd5e1 #f1f1f1;
        }

        #chat-tabs::-webkit-scrollbar {
            height: 6px;
        }

        #chat-tabs::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }

        #chat-tabs::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 3px;
        }

        #chat-tabs::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }

        /* Markdown Styles */
        .markdown-content h1 { @apply text-2xl font-bold mb-4 mt-6; }
        .markdown-content h2 { @apply text-xl font-bold mb-3 mt-5; }
        .markdown-content h3 { @apply text-lg font-bold mb-2 mt-4; }
        .markdown-content p { @apply mb-4 leading-relaxed; }
        .markdown-content ul { @apply list-disc ml-6 mb-4 space-y-2; }
        .markdown-content ol { @apply list-decimal ml-6 mb-4 space-y-2; }
        .markdown-content blockquote { @apply border-l-4 border-blue-300 pl-4 italic my-4 bg-blue-50 py-2 rounded-r; }
        .markdown-content code { @apply bg-gray-100 px-1.5 py-0.5 rounded text-sm font-mono; }
        .markdown-content pre { @apply bg-gray-50 p-4 rounded-lg mb-4 overflow-x-auto shadow-sm; }
        .markdown-content a { @apply text-blue-600 hover:text-blue-800 underline; }
        .markdown-content table { @apply min-w-full border border-gray-200 mb-4 rounded-lg overflow-hidden; }
        .markdown-content th { @apply bg-gray-50 border px-4 py-2 text-left; }
        .markdown-content td { @apply border px-4 py-2; }
        .markdown-content img { @apply max-w-full h-auto rounded-lg shadow-sm; }
        .markdown-content hr { @apply my-6 border-t border-gray-200; }
        .markdown-content strong { @apply font-semibold; }
        .markdown-content em { @apply italic; }

        /* Animation */
        @keyframes slideIn {
            from { transform: translateY(10px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .message-animation {
            animation: slideIn 0.3s ease-out forwards;
        }

        .chat-tab-active {
            background-color: #3b82f6;
            color: white;
        }
    </style>
</head>
<body class="bg-gradient-to-br from-gray-50 to-gray-100 min-h-screen">
    <div class="container mx-auto px-4 py-8">
        <!-- Chat tabs -->
        <div class="max-w-full mx-auto mb-4 bg-white rounded-xl shadow-xl overflow-hidden border border-gray-100">
            <div class="flex items-center p-4 border-b border-gray-100">
                <div class="flex space-x-2 overflow-x-auto" id="chat-tabs">
                    <!-- Chat tabs will be inserted here -->
                    <button onclick="createNewChat()" class="px-4 py-2 text-blue-600 hover:bg-blue-50 rounded-lg flex items-center">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"/>
                        </svg>
                        New Chat
                    </button>
                </div>
            </div>
        </div>

        <!-- Main content area -->
        <div class="flex gap-4">
            <!-- Left side: Chat interface -->
            <div class="flex-grow max-w-4xl bg-white rounded-xl shadow-xl overflow-hidden border border-gray-100">
                <!-- Header -->
                <div class="bg-white border-b border-gray-100 p-6">
                    <div class="flex flex-col sm:flex-row justify-between items-center gap-4">
                        <h1 class="text-2xl font-semibold text-gray-800 flex items-center gap-2">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-blue-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 10h.01M12 10h.01M16 10h.01M9 16H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-4l-4 4-4-4z"/>
                            </svg>
                            Document Chat
                        </h1>
                        <div class="flex flex-wrap gap-4 items-center">
                            <select id="api-select" class="bg-white border border-gray-200 rounded-lg px-4 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                                {% for api in apis %}
                                <option value="{{ api }}">{{ api|title }}</option>
                                {% endfor %}
                            </select>
                            <label class="flex items-center gap-2 text-sm text-gray-600">
                                <input type="checkbox" id="stream-toggle" class="w-4 h-4 text-blue-500 rounded focus:ring-blue-500" checked>
                                Stream Response
                            </label>
                            <button onclick="clearChat()" class="text-red-500 hover:text-red-600 transition-colors flex items-center gap-2 text-sm font-medium">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
                                </svg>
                                Clear Chat
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Chat Messages -->
                <div id="chat-messages" class="h-[calc(100vh-320px)] overflow-y-auto p-6 space-y-6 bg-gray-50"></div>

                <!-- Input Area -->
                <div class="border-t border-gray-100 p-6 bg-white">
                    <div class="flex gap-4">
                        <input type="text" id="message-input"
                               class="flex-1 bg-gray-50 border border-gray-200 rounded-lg px-4 py-3 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent placeholder-gray-400"
                               placeholder="Type your message...">
                        <button onclick="sendMessage()"
                                class="bg-blue-500 text-white px-6 py-3 rounded-lg hover:bg-blue-600 transition-all duration-200 flex items-center gap-2 font-medium">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"/>
                            </svg>
                            Send
                        </button>
                    </div>
                </div>
            </div>

            <!-- Right side: Files panel -->
            <div class="w-80 bg-white rounded-xl shadow-xl overflow-hidden border border-gray-100 h-[calc(100vh-120px)]">
                <div class="p-4 border-b border-gray-100">
                    <h3 class="text-lg font-semibold text-gray-800">Uploaded Files</h3>
                    <label class="mt-4 bg-blue-500 text-white px-4 py-2 rounded-lg hover:bg-blue-600 transition-all duration-200 cursor-pointer flex items-center gap-2 text-sm font-medium">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"/>
                        </svg>
                        Upload Files
                        <input type="file" id="file-input" class="hidden" multiple accept=".pdf,.txt,.doc,.docx">
                    </label>
                </div>
                <div id="file-list" class="p-4 space-y-2 overflow-y-auto max-h-[calc(100%-120px)]">
                    <!-- Files will be listed here -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // Configure marked for syntax highlighting
        marked.setOptions({
            highlight: function(code, lang) {
                if (lang && hljs.getLanguage(lang)) {
                    try {
                        return hljs.highlight(code, { language: lang }).value;
                    } catch (e) {}
                }
                try {
                    return hljs.highlightAuto(code).value;
                } catch (e) {}
                return code;
            }
        });


        let chatStates = {
            'chat-1': {
                messages: [],
                files: [],
                currentStream: null,
                pendingResponse: null
            }
        };

        let currentChatId = 'chat-1';

        // Initialize event listeners and UI
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize first chat
            addChatTab('chat-1');
            switchToChat('chat-1');

            // Setup event listeners
            const messageInput = document.getElementById('message-input');
            messageInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    sendMessage();
                }
            });

            const fileInput = document.getElementById('file-input');
            fileInput.addEventListener('change', handleFileUpload);
        });

        function createNewChat() {
            fetch('/create-chat', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.success && data.chatId) {
                    // Initialize new chat state
                    chatStates[data.chatId] = {
                        messages: [],
                        files: [],
                        currentStream: null,
                        pendingResponse: null
                    };

                    // Add and switch to new chat tab
                    addChatTab(data.chatId);
                    switchToChat(data.chatId);
                } else {
                    throw new Error(data.error || 'Failed to create chat');
                }
            })
            .catch(error => {
                console.error('Error creating new chat:', error);
                showError('Failed to create new chat');
            });
        }

        function addChatTab(chatId) {
            const tabsContainer = document.getElementById('chat-tabs');
            if (!tabsContainer) {
                console.error('Chat tabs container not found');
                return;
            }

            const tab = document.createElement('div');
            tab.className = 'flex items-center px-4 py-2 bg-gray-100 rounded-lg mr-2 cursor-pointer';
            tab.innerHTML = `
                <span class="mr-2">Chat ${chatId.split('-')[1]}</span>
                <button onclick="closeChat('${chatId}', event)" class="text-gray-500 hover:text-red-500">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                    </svg>
                </button>
            `;
            tab.setAttribute('data-chat-id', chatId);
            tab.onclick = (e) => {
                const closeButton = e.target.closest('button');
                if (!closeButton) {
                    switchToChat(chatId);
                }
            };

            // Find the New Chat button by its specific characteristics
            const newChatButton = Array.from(tabsContainer.children).find(child =>
                child.tagName === 'BUTTON' &&
                child.textContent.trim().includes('New Chat')
            );

            // If we found the New Chat button, insert before it, otherwise append to the end
            if (newChatButton) {
                tabsContainer.insertBefore(tab, newChatButton);
            } else {
                // If we can't find the New Chat button, just append the new tab
                tabsContainer.appendChild(tab);

                // Re-create the New Chat button if it's missing
                const newButton = document.createElement('button');
                newButton.className = 'px-4 py-2 text-blue-600 hover:bg-blue-50 rounded-lg flex items-center';
                newButton.onclick = createNewChat;
                newButton.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"/>
                    </svg>
                    New Chat
                `;
                tabsContainer.appendChild(newButton);
            }

            updateActiveTabStyle(chatId);
        }

        function switchToChat(chatId) {
            // Cancel any ongoing stream in the current chat
            if (chatStates[currentChatId]?.currentStream) {
                chatStates[currentChatId].currentStream.abort();
                chatStates[currentChatId].currentStream = null;
            }

            currentChatId = chatId;

            // Initialize chat state if it doesn't exist
            if (!chatStates[chatId]) {
                chatStates[chatId] = {
                    messages: [],
                    files: [],
                    currentStream: null,
                    pendingResponse: null
                };
            }

            // Update UI to show current chat's messages
            const chatMessages = document.getElementById('chat-messages');
            chatMessages.innerHTML = '';

            // Render all messages for this chat
            chatStates[chatId].messages.forEach(msg => {
                appendMessage(msg.content, msg.isUser);
            });

            // If there's a pending response, render it
            if (chatStates[chatId].pendingResponse) {
                appendMessage(chatStates[chatId].pendingResponse, false);
            }

            // Update files panel
            const fileList = document.getElementById('file-list');
            fileList.innerHTML = '';
            chatStates[chatId].files.forEach(file => {
                addFileToPreview(file.displayName || file.name, file.name);
            });

            // Update active tab styling
            document.querySelectorAll('#chat-tabs > div').forEach(tab => {
                if (tab.getAttribute('data-chat-id') === chatId) {
                    tab.classList.add('bg-blue-100');
                    tab.classList.remove('bg-gray-100');
                } else {
                    tab.classList.remove('bg-blue-100');
                    tab.classList.add('bg-gray-100');
                }
            });
        }


        function closeChat(chatId, event) {
            // Prevent the click from triggering the chat switch
            if (event) {
                event.stopPropagation();
            }

            // Count active chats
            const activeChats = Object.keys(chatStates).length;
            if (activeChats <= 1) {
                showError("Cannot delete the last chat");
                return;
            }

            // Find another chat to switch to before closing this one
            const otherChatId = Object.keys(chatStates).find(id => id !== chatId);

            fetch(`/close-chat/${encodeURIComponent(chatId)}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                credentials: 'same-origin'
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                if (data.success) {
                    // Remove chat state
                    delete chatStates[chatId];

                    // Remove tab from UI
                    const tab = document.querySelector(`[data-chat-id="${chatId}"]`);
                    if (tab) {
                        tab.remove();
                    }

                    // If we closed the current chat, switch to another one
                    if (chatId === currentChatId && otherChatId) {
                        switchToChat(otherChatId);
                    }
                } else {
                    throw new Error(data.error || 'Failed to close chat');
                }
            })
            .catch(error => {
                console.error('Error closing chat:', error);
                showError(error.message || 'Failed to close chat');
            });
        }


        function handleFileUpload(event) {
            const files = event.target.files;
            if (!files.length) return;

            Array.from(files).forEach(file => {
                const formData = new FormData();
                formData.append('file', file);
                formData.append('chatId', currentChatId);

                fetch('/upload', {
                    method: 'POST',
                    body: formData
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // Store both the actual filename and display name
                        chatStates[currentChatId].files.push({
                            name: data.filename,
                            displayName: data.displayName
                        });

                        addFileToPreview(data.displayName, data.filename);

                        // Add status message to chat
                        const statusMessage = `File "${data.displayName}" has been uploaded and added to the context.`;
                        appendMessage(statusMessage, false);
                        chatStates[currentChatId].messages.push({
                            content: statusMessage,
                            isUser: false
                        });
                    } else {
                        showError(data.error || 'Failed to upload file');
                    }
                })
                .catch(error => {
                    showError('Error uploading file');
                    console.error('Upload error:', error);
                });
            });

            // Clear the file input
            event.target.value = '';
        }

        function updateFileCount(change) {
            const chat = chats.find(c => c.id === currentChatId);
            if (!chat) return;

            if (!chat.files) chat.files = [];
            const currentCount = chat.files.length + (change || 0);

            const fileCount = document.getElementById('file-count');
            if (fileCount) {
                fileCount.textContent = `${currentCount} uploaded`;
            }
        }

        function addFileToPreview(displayName, actualFilename) {
            const fileList = document.getElementById('file-list');
            if (!fileList) return;

            const fileDiv = document.createElement('div');
            fileDiv.className = 'flex items-center justify-between bg-white px-3 py-2 rounded-lg border border-gray-200 shadow-sm';
            fileDiv.dataset.filename = actualFilename;

            fileDiv.innerHTML = `
                <div class="flex items-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-gray-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 3H7a2 2 0 00-2 2v14a2 2 0 002 2z"/>
                    </svg>
                    <span class="text-sm text-gray-700 truncate">${displayName}</span>
                </div>
                <button onclick="removeFile('${actualFilename}')" class="text-gray-400 hover:text-red-500 transition-colors">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                    </svg>
                </button>
            `;

            fileList.appendChild(fileDiv);
        }

        function removeFile(filename) {
            fetch(`/remove-file/${filename}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    chatId: currentChatId
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Remove file from UI
                    const fileElements = document.querySelectorAll('#file-list > div');
                    fileElements.forEach(el => {
                        if (el.dataset.filename === filename) {
                            el.remove();
                        }
                    });

                    // Remove file from chat state
                    chatStates[currentChatId].files = chatStates[currentChatId].files.filter(
                        f => f.name !== filename
                    );
                } else {
                    console.error('Failed to remove file:', data.error);
                }
            })
            .catch(error => {
                console.error('Error removing file:', error);
            });
        }

        function formatMarkdown(content, isUser) {
            if (isUser) return content;
            try {
                return marked.parse(content);
            } catch (e) {
                console.error('Markdown parsing error:', e);
                return content;
            }
        }

        function appendMessage(content, isUser = false) {
            const chatMessages = document.getElementById('chat-messages');
            if (!chatMessages) {
                console.error('Chat messages container not found');
                return null;
            }

            const messageDiv = document.createElement('div');
            messageDiv.className = `flex ${isUser ? 'justify-end' : 'justify-start'} message-animation`;

            const messageBubble = document.createElement('div');
            messageBubble.className = `max-w-[80%] rounded-lg p-4 ${
                isUser ? 'bg-blue-500 text-white shadow-sm' : 'bg-white text-gray-800 shadow-sm markdown-content'
            }`;

            if (isUser) {
                messageBubble.textContent = content;
                // Store user message in chat state
                chatStates[currentChatId].messages.push({
                    content: content,
                    isUser: true,
                    timestamp: new Date().toISOString()
                });
            } else {
                messageBubble.innerHTML = formatMarkdown(content);
                messageBubble.querySelectorAll('pre code').forEach((block) => {
                    hljs.highlightBlock(block);
                });
            }

            messageDiv.appendChild(messageBubble);
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;

            return messageBubble;
        }

        function sendMessage() {
            const messageInput = document.getElementById('message-input');
            const message = messageInput.value.trim();
            if (!message) return;

            const streamMode = document.getElementById('stream-toggle').checked;
            appendMessage(message, true);
            messageInput.value = '';
            messageInput.disabled = true;

            if (streamMode) {
                handleStreamingResponse(message);
            } else {
                handleNormalResponse(message);
            }
        }

        function handleStreamingResponse(message) {
            const chatMessages = document.getElementById('chat-messages');
            const messageInput = document.getElementById('message-input');
            const responseBubble = appendMessage('', false);
            let fullResponse = '';

            // Create AbortController for the stream
            const controller = new AbortController();
            chatStates[currentChatId].currentStream = controller;

            fetch('/chat/stream', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    message: message,
                    api: document.getElementById('api-select').value,
                    chatId: currentChatId
                }),
                signal: controller.signal
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';

                function processText(text) {
                    const lines = text.split('\n');
                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const data = line.slice(6);
                            if (data === '[DONE]') {
                                // Store the complete response in chat state
                                if (fullResponse) {
                                    chatStates[currentChatId].messages.push({
                                        content: fullResponse,
                                        isUser: false,
                                        timestamp: new Date().toISOString()
                                    });
                                }
                                chatStates[currentChatId].pendingResponse = null;
                                return true;
                            }
                            try {
                                const parsed = JSON.parse(data);
                                if (parsed.error) {
                                    responseBubble.innerHTML = formatMarkdown(`Error: ${parsed.error}`);
                                    return true;
                                }
                                if (parsed.content) {
                                    fullResponse += parsed.content;
                                    responseBubble.innerHTML = formatMarkdown(fullResponse);
                                    // Store the partial response
                                    chatStates[currentChatId].pendingResponse = fullResponse;
                                    responseBubble.querySelectorAll('pre code').forEach((block) => {
                                        hljs.highlightBlock(block);
                                    });
                                    if (chatMessages) {
                                        chatMessages.scrollTop = chatMessages.scrollHeight;
                                    }
                                }
                            } catch (e) {
                                console.error('Failed to parse JSON:', e, data);
                            }
                        }
                    }
                    return false;
                }

                function pump() {
                    return reader.read().then(({done, value}) => {
                        if (done) {
                            if (buffer) processText(buffer);
                            if (messageInput) {
                                messageInput.disabled = false;
                                messageInput.focus();
                            }
                            chatStates[currentChatId].currentStream = null;
                            return;
                        }

                        buffer += decoder.decode(value, {stream: true});
                        const lines = buffer.split('\n\n');
                        buffer = lines.pop();

                        for (const line of lines) {
                            if (processText(line)) {
                                reader.cancel();
                                if (messageInput) {
                                    messageInput.disabled = false;
                                    messageInput.focus();
                                }
                                chatStates[currentChatId].currentStream = null;
                                return;
                            }
                        }

                        return pump();
                    });
                }

                return pump();
            })
            .catch(error => {
                if (error.name === 'AbortError') {
                    console.log('Stream was cancelled');
                } else {
                    console.error('Streaming error:', error);
                    responseBubble.innerHTML = formatMarkdown('An error occurred while streaming the response. Please try again.');
                }
                if (messageInput) {
                    messageInput.disabled = false;
                    messageInput.focus();
                }
                chatStates[currentChatId].currentStream = null;
            });
        }


        function handleNormalResponse(message) {
            fetch('/chat/message', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    message: message,
                    api: document.getElementById('api-select').value,
                    chatId: currentChatId
                })
            })
            .then(response => response.json())
            .then(data => {
                const messageInput = document.getElementById('message-input');
                if (data.error) {
                    appendMessage(`Error: ${data.error}`, false);
                } else {
                    appendMessage(data.response, false);
                    // Store the response in chat state
                    chatStates[currentChatId].messages.push({
                        content: data.response,
                        isUser: false,
                        timestamp: new Date().toISOString()
                    });
                }
                messageInput.disabled = false;
                messageInput.focus();
            })
            .catch(error => {
                console.error('Chat error:', error);
                appendMessage('An error occurred. Please try again.', false);
                const messageInput = document.getElementById('message-input');
                messageInput.disabled = false;
                messageInput.focus();
            });
        }

        function showError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'bg-red-50 border-l-4 border-red-500 text-red-700 p-4 mb-4 rounded-r-lg shadow-sm message-animation fixed top-4 right-4 z-50';
            errorDiv.textContent = message;
            document.body.appendChild(errorDiv);

            setTimeout(() => {
                errorDiv.style.animation = 'slideIn 0.3s reverse';
                setTimeout(() => errorDiv.remove(), 300);
            }, 4000);
        }

        function clearChat() {
            if (!confirm('Are you sure you want to clear the chat and remove all uploaded files?')) return;

            fetch('/clear-chat', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    chatId: currentChatId
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Clear current chat state
                    chatStates[currentChatId] = {
                        messages: [],
                        files: [],
                        currentStream: null,
                        pendingResponse: null
                    };

                    // Clear UI
                    document.getElementById('file-list').innerHTML = '';
                    document.getElementById('chat-messages').innerHTML = '';
                    document.getElementById('file-input').value = '';
                } else {
                    showError(data.error || 'Failed to clear chat');
                }
            })
            .catch(error => {
                console.error('Error clearing chat:', error);
                showError('Failed to clear chat');
            });
        }

        function clearFiles() {
            const chat = chats.find(c => c.id === currentChatId);
            if (chat) {
                chat.files = [];
                const fileList = document.getElementById('file-list');
                if (fileList) {
                    fileList.innerHTML = '';
                }
                updateFileCount(0);
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            // First get the initial chat state from the server
            fetch('/init-chats')
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // Clear existing chat tabs
                        const tabsContainer = document.getElementById('chat-tabs');
                        // Keep only the "New Chat" button
                        tabsContainer.innerHTML = `
                            <button onclick="createNewChat()" class="px-4 py-2 text-blue-600 hover:bg-blue-50 rounded-lg flex items-center">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"/>
                                </svg>
                                New Chat
                            </button>
                        `;

                        // Initialize chat states from server data
                        chatStates = {};
                        Object.keys(data.chats).forEach(chatId => {
                            // Initialize chat state with messages and files from server
                            chatStates[chatId] = {
                                messages: data.chats[chatId].messages || [],
                                files: data.chats[chatId].files || [],
                                currentStream: null,
                                pendingResponse: null
                            };

                            // Create the chat tab
                            addChatTab(chatId);
                        });

                        // Switch to the first chat if it exists
                        const firstChatId = Object.keys(chatStates)[0];
                        if (firstChatId) {
                            switchToChat(firstChatId);
                        }
                    }
                })
                .catch(error => {
                    console.error('Error initializing chats:', error);
                    showError('Failed to initialize chats');
                });

            // Setup event listeners
            const messageInput = document.getElementById('message-input');
            messageInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                }
            });

            const fileInput = document.getElementById('file-input');
            fileInput.addEventListener('change', handleFileUpload);

            // Add stream toggle listener
            const streamToggle = document.getElementById('stream-toggle');
            if (streamToggle) {
                streamToggle.addEventListener('change', function() {
                    if (!this.checked && chatStates[currentChatId]?.currentStream) {
                        chatStates[currentChatId].currentStream.abort();
                        chatStates[currentChatId].currentStream = null;
                    }
                });
            }
        });

        function formatMarkdown(content) {
            try {
                // Configure marked for code highlighting
                marked.setOptions({
                    highlight: function(code, lang) {
                        if (lang && hljs.getLanguage(lang)) {
                            try {
                                return hljs.highlight(code, { language: lang }).value;
                            } catch (e) { }
                        }
                        try {
                            return hljs.highlightAuto(code).value;
                        } catch (e) { }
                        return code;
                    },
                    breaks: true,
                    gfm: true
                });

                return marked.parse(content);
            } catch (e) {
                console.error('Markdown parsing error:', e);
                return content;
            }
        }

        function isInViewport(element) {
            const rect = element.getBoundingClientRect();
            return (
                rect.top >= 0 &&
                rect.left >= 0 &&
                rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
                rect.right <= (window.innerWidth || document.documentElement.clientWidth)
            );
        }

        function appendMessage(content, isUser = false) {
            const chatMessages = document.getElementById('chat-messages');
            if (!chatMessages) {
                console.error('Chat messages container not found');
                return null;
            }

            const messageDiv = document.createElement('div');
            messageDiv.className = `flex ${isUser ? 'justify-end' : 'justify-start'} message-animation`;

            const messageBubble = document.createElement('div');
            messageBubble.className = `max-w-[80%] rounded-lg p-4 ${
                isUser ? 'bg-blue-500 text-white shadow-sm' : 'bg-white text-gray-800 shadow-sm markdown-content'
            }`;

            if (isUser) {
                messageBubble.textContent = content;
                // Store user message in chat state
                chatStates[currentChatId].messages.push({
                    content: content,
                    isUser: true
                });
            } else {
                messageBubble.innerHTML = formatMarkdown(content);
                messageBubble.querySelectorAll('pre code').forEach((block) => {
                    hljs.highlightBlock(block);
                });
                // Only store non-user messages if they're not temporary (streaming) responses
                if (!chatStates[currentChatId].pendingResponse) {
                    chatStates[currentChatId].messages.push({
                        content: content,
                        isUser: false
                    });
                }
            }

            messageDiv.appendChild(messageBubble);
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;

            return messageBubble;
        }

        function updateActiveTabStyle(activeChatId) {
            const tabs = document.querySelectorAll('[data-chat-id]');
            tabs.forEach(tab => {
                if (tab.getAttribute('data-chat-id') === activeChatId) {
                    tab.classList.remove('bg-gray-100');
                    tab.classList.add('bg-blue-100');
                } else {
                    tab.classList.remove('bg-blue-100');
                    tab.classList.add('bg-gray-100');
                }
            });
        }

    </script>
</body>
</html>